{
    "boilerplate": {
        "prefix": "boilerplate",
        "body": [
            "/*",
            "author : NISHCHAY JANGADHIYA",
            "*/",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define int int64_t",
            "const int MOD = (int)1e9 + 7;",
            "#define f first",
            "#define s second",
            "",
            "void solve() {",
            "    // Your solution here",
            "",
            "}",
            "",
            "int32_t main() {",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "    int t = 1;",
            "    // freopen(\"in\", \"r\", stdin);",
            "    // freopen(\"out\", \"w\", stdout);",
            "    // cin >> t; // Uncomment if you want multiple test cases",
            "    while (t--) {",
            "        solve();",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "C++ boilerplate code with standard includes and main function"
    },
    "segment_tree": {
        "prefix": "seg_tree",
        "body": [
            "const int N = 1e5 + 5;",
            "int n;",
            "int a[N], b[N];",
            "",
            "struct SegTree {",
            "    int N;",
            "    vector<int> st;",
            "",
            "    void init(int n) {",
            "        N = n;",
            "        st.resize(4 * N + 5);",
            "    }",
            "",
            "    void Build(int node, int L, int R) {",
            "        if (L == R) {",
            "            st[node] = b[L];",
            "            return;",
            "        }",
            "        int M = (L + R) / 2;",
            "        Build(node * 2, L, M);",
            "        Build(node * 2 + 1, M + 1, R);",
            "        st[node] = max(st[node * 2], st[node * 2 + 1]);",
            "    }",
            "",
            "    void Update(int node, int L, int R, int pos, int val) {",
            "        if (L == R) {",
            "            st[node] += val;",
            "            return;",
            "        }",
            "        int M = (L + R) / 2;",
            "        if (pos <= M)",
            "            Update(node * 2, L, M, pos, val);",
            "        else",
            "            Update(node * 2 + 1, M + 1, R, pos, val);",
            "",
            "        st[node] = max(st[node * 2], st[node * 2 + 1]);",
            "    }",
            "",
            "    int Query(int node, int L, int R, int i, int j) {",
            "        if (j < L || i > R)",
            "            return 0;",
            "        if (i <= L && R <= j)",
            "            return st[node];",
            "        int M = (L + R) / 2;",
            "        return max(Query(node * 2, L, M, i, j), Query(node * 2 + 1, M + 1, R, i, j));",
            "    }",
            "",
            "    // Public methods for ease of use",
            "    int query(int l, int r) { return Query(1, 1, N, l, r); }",
            "    void update(int pos, int val) { Update(1, 1, N, pos, val); }",
            "    void build() { Build(1, 1, N); }",
            "};"
        ],
        "description": "Segment tree class with build, query, and update methods"
    },
    "depth_first_search": {
        "prefix": "dfs",
        "body": [
            "void dfs(int node, vector<vector<int>>& adjList, vector<bool>& visited) {",
            "    visited[node] = true;",
            "    for (int neighbor : adjList[node]) {",
            "        if (!visited[neighbor]) {",
            "            dfs(neighbor, adjList, visited);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Depth-First Search (DFS) function and its implementation"
    },
    "power": {
        "prefix": "power",
        "body": [
            "int power(int a, int b, int m = MOD) {",
            "    int res = 1;",
            "    while (b > 0) {",
            "        if (b & 1) res = (res * a) % m;",
            "        a = (a * a) % m;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Power function with modular arithmetic"
    },
    "nCr": {
        "prefix": "ncr",
        "body": [
            "int nCr(int n, int r) {",
            "    if (r > n) return 0;",
            "    if (r == 0 || n == r) return 1;",
            "    int num = 1, denom = 1;",
            "    for (int i = 0; i < r; i++) {",
            "        num = (num * (n - i)) % MOD;",
            "        denom = (denom * (i + 1)) % MOD;",
            "    }",
            "    return (num * power(denom, MOD - 2)) % MOD;",
            "}"
        ],
        "description": "nCr calculation using modular arithmetic"
    },"modInverse": {
        "prefix": "modinverse",
        "body": [
            "long long modInverse(long long a, long long m) {",
            "    long long m0 = m;",
            "    long long y = 0, x = 1;",
            "    ",
            "    if (m == 1) return 0;",
            "    ",
            "    while (a > 1) {",
            "        long long q = a / m;",
            "        long long t = m;",
            "        m = a % m;",
            "        a = t;",
            "        t = y;",
            "        y = x - q * y;",
            "        x = t;",
            "    }",
            "    ",
            "    if (x < 0) x += m0;",
            "    return x;",
            "}"
        ],
        "description": "Modular Multiplicative Inverse using Extended Euclidean Algorithm"
    },
    "DSU_Rank": {
    "prefix": "DSU_Rank",
    "body": [
        "",
        "class DSU {",
        "private:",
        "    vector<int> parent;",
        "    vector<int> rank;",
        "",
        "public:",
        "    DSU(int n) {",
        "        parent.resize(n);",
        "        rank.resize(n, 1);  // Initialize rank (or size) to 1 for each element",
        "        for (int i = 0; i < n; i++) {",
        "            parent[i] = i;  // Each element is its own parent initially",
        "        }",
        "    }",
        "",
        "    int find(int x) {",
        "        // Path compression: make each node point directly to the root",
        "        if (parent[x] != x) {",
        "            parent[x] = find(parent[x]);  // Recursively find root and compress path",
        "        }",
        "        return parent[x];",
        "    }",
        "",
        "    void unionSets(int x, int y) {",
        "        int rootX = find(x);",
        "        int rootY = find(y);",
        "",
        "        if (rootX != rootY) {",
        "            // Union by rank: attach smaller tree under root of larger tree",
        "            if (rank[rootX] > rank[rootY]) {",
        "                parent[rootY] = rootX;",
        "            } else if (rank[rootX] < rank[rootY]) {",
        "                parent[rootX] = rootY;",
        "            } else {",
        "                parent[rootY] = rootX;",
        "                rank[rootX] += 1;  // Increase rank if both have the same rank",
        "            }",
        "        }",
        "    }",
        "};"
    ],
    "description": "Disjoint Set Union (DSU) class with union and find operations"
}, "DSU_size": {
    "prefix": "DSU_size",
    "body": [
        "",
        "class DSU {",
        "private:",
        "    vector<int> parent;",
        "    vector<int> size;",
        "",
        "public:",
        "    DSU(int n) {",
        "        parent.resize(n);",
        "        size.resize(n, 1);  // Initialize size to 1 for each element",
        "        for (int i = 0; i < n; i++) {",
        "            parent[i] = i;  // Each element is its own parent initially",
        "        }",
        "    }",
        "",
        "    int find(int x) {",
        "        // Path compression: make each node point directly to the root",
        "        if (parent[x] != x) {",
        "            parent[x] = find(parent[x]);  // Recursively find root and compress path",
        "        }",
        "        return parent[x];",
        "    }",
        "",
        "    void unionSets(int x, int y) {",
        "        int rootX = find(x);",
        "        int rootY = find(y);",
        "",
        "        if (rootX != rootY) {",
        "            // Union by size: attach smaller tree under root of larger tree",
        "            if (size[rootX] < size[rootY]) {",
        "                parent[rootX] = rootY;",
        "                size[rootY] += size[rootX];",
        "            } else {",
        "                parent[rootY] = rootX;",
        "                size[rootX] += size[rootY];",
        "            }",
        "        }",
        "    }",
        "};"
    ],
    "description": "Disjoint Set Union (DSU) class with union and find operations using size-based union"
}
}
