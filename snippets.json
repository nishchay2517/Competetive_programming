{
    "boilerplate": {
        "prefix": "boilerplate",
        "body": [
            "/*",
            "author : NISHCHAY JANGADHIYA",
            "*/",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define int int64_t",
            "const int MOD = (int)1e9 + 7;",
            "#define f first",
            "#define s second",
            "",
            "void solve() {",
            "    // Your solution here",
            "   int n;",
            "   cin>>n;",
            "   vector<int> v(n);",
            "   for(auto &it:v) cin>>it;",
            "",
            "}",
            "",
            "int32_t main() {",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "    int t = 1;",
            "    // freopen(\"in\", \"r\", stdin);",
            "    // freopen(\"out\", \"w\", stdout);",
            "    // cin >> t; // Uncomment if you want multiple test cases",
            "    while (t--) {",
            "        solve();",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "C++ boilerplate code with standard includes and main function"
    },
    "segment_tree": {
        "prefix": "seg_tree",
        "body": [
            "const int N = 1e5 + 5;",
            "int n;",
            "int a[N], b[N];",
            "",
            "struct SegTree {",
            "    int N;",
            "    vector<int> st;",
            "",
            "    void init(int n) {",
            "        N = n;",
            "        st.resize(4 * N + 5);",
            "    }",
            "",
            "    void Build(int node, int L, int R) {",
            "        if (L == R) {",
            "            st[node] = b[L];",
            "            return;",
            "        }",
            "        int M = (L + R) / 2;",
            "        Build(node * 2, L, M);",
            "        Build(node * 2 + 1, M + 1, R);",
            "        st[node] = max(st[node * 2], st[node * 2 + 1]);",
            "    }",
            "",
            "    void Update(int node, int L, int R, int pos, int val) {",
            "        if (L == R) {",
            "            st[node] += val;",
            "            return;",
            "        }",
            "        int M = (L + R) / 2;",
            "        if (pos <= M)",
            "            Update(node * 2, L, M, pos, val);",
            "        else",
            "            Update(node * 2 + 1, M + 1, R, pos, val);",
            "",
            "        st[node] = max(st[node * 2], st[node * 2 + 1]);",
            "    }",
            "",
            "    int Query(int node, int L, int R, int i, int j) {",
            "        if (j < L || i > R)",
            "            return 0;",
            "        if (i <= L && R <= j)",
            "            return st[node];",
            "        int M = (L + R) / 2;",
            "        return max(Query(node * 2, L, M, i, j), Query(node * 2 + 1, M + 1, R, i, j));",
            "    }",
            "",
            "    // Public methods for ease of use",
            "    int query(int l, int r) { return Query(1, 1, N, l, r); }",
            "    void update(int pos, int val) { Update(1, 1, N, pos, val); }",
            "    void build() { Build(1, 1, N); }",
            "};"
        ],
        "description": "Segment tree class with build, query, and update methods"
    },
    "depth_first_search": {
        "prefix": "dfs",
        "body": [
            "void dfs(int node, vector<vector<int>>& adjList, vector<bool>& visited) {",
            "    visited[node] = true;",
            "    for (int neighbor : adjList[node]) {",
            "        if (!visited[neighbor]) {",
            "            dfs(neighbor, adjList, visited);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Depth-First Search (DFS) function and its implementation"
    }
}
